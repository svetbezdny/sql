[stepik.org](https://stepik.org/lesson/909263/step/9?thread=solutions&unit=914865)  

*Есть таблица activity, которая хранит баллы, набранные пользователями в конкретные дни:*   

|   adate  |user_id|points|
|----------|-------|------|
|2020-02-02|  11   |  1   |
|2020-02-03|  11   |  1   |
|2020-02-04|  11   |  1   |
|2020-02-05|  11   |  1   |
|   ...    |  ...  |  ... |
|2020-02-25|  51   |  1   |

1. **Создание таблицы activity**

```sql
create table activity (
  adate date,
  user_id integer,
  points integer
);

insert into activity values
('2020-02-02', 11, 1),
('2020-02-03', 11, 1),
('2020-02-04', 11, 1),
('2020-02-05', 11, 1),
('2020-02-06', 11, 1),
('2020-02-07', 11, 1),
('2020-02-08', 11, 1),
('2020-02-09', 11, 1),
('2020-02-10', 11, 1),
('2020-02-11', 11, 1),
('2020-02-15', 11, 2),
('2020-02-16', 11, 2),
('2020-02-17', 11, 2),
('2020-02-05', 21, 6),
('2020-02-07', 21, 2),
('2020-02-09', 21, 4),
('2020-02-11', 21, 6),
('2020-02-13', 21, 3),
('2020-02-15', 21, 5),
('2020-02-20', 21, 5),
('2020-02-23', 21, 3),
('2020-02-24', 21, 1),
('2020-02-07', 31, 25),
('2020-02-11', 31, 2),
('2020-02-12', 31, 3),
('2020-02-13', 31, 2),
('2020-02-01', 51, 1),
('2020-02-02', 51, 3),
('2020-02-03', 51, 2),
('2020-02-04', 51, 6),
('2020-02-05', 51, 3),
('2020-02-08', 51, 1),
('2020-02-09', 51, 1),
('2020-02-10', 51, 1),
('2020-02-20', 51, 9),
('2020-02-21', 51, 15),
('2020-02-22', 51, 7),
('2020-02-25', 51, 1);
```

*Серией считается последовательность дней, в которых количество набранных пользователем очков в каждый следующий день не меньше, чем в предыдущий.*  
*При этом между предыдущим и следующим днем может быть любой промежуток времени, это не прерывает серию.*  
*Серии из одного дня не учитываются.*  

*Напишите запрос, который считает серии для каждого пользователя.*

2. **Решение**

```sql
with t as (
	select 
	  user_id,
	  adate,
	  points,
	  points - lag(points) over (partition by user_id order by adate) as points_lag
	from activity )
select 
  user_id,
  min(adate) as day_start, max(adate) as day_end,
  count(*) as day_count, sum(points) as p_total
from (
	select 
	  user_id,
	  adate,
	  points,
	  points_lag,
	  sum(case when points_lag < 0 then 1 else 0 end) over (partition by user_id order by adate) as gr
	from t ) foo
group by gr, user_id
having count(*) > 1
order by user_id, day_start;
```

|user_id|day_start |day_end   |day_count|p_total|
|-------|----------|----------|---------|-------|
|   11  |2020-02-02|2020-02-17|  13     |   16  |
|   21  |2020-02-07|2020-02-11|  3      |   12  |
|   21  |2020-02-13|2020-02-20|  3      |   13  |
|   31  |2020-02-11|2020-02-12|  2      |    5  |
|   51  |2020-02-01|2020-02-02|  2      |    4  |
|   51  |2020-02-03|2020-02-04|  2      |    8  |
|   51  |2020-02-08|2020-02-21|  5      |   27  |